import re
from typing import Dict, List, Literal, Optional


class RustErrorMessages:
    """
    A class to store and represent error messages from the Rust compiler.

    This class encapsulates the details of an error message generated by the Rust compiler,
    providing a structured way to access and manipulate error message data.

    :param kind: The type of the message, which can be "error", "note", or "warning".
    :type kind: Literal["error", "note", "warning"]
    :param error_code: The error code associated with the message, if any.
    :type error_code: Optional[str]
    :param msg: The text of the error message.
    :type msg: str
    :param file: The file in which the error occurred.
    :type file: str
    :param row: The row number in the file where the error occurred.
    :type row: int
    :param col: The column number in the file where the error occurred.
    :type col: int
    :param refer: A dictionary of references with integer keys and string values.
    :type refer: Dict[int, str]
    :param extra: Additional context or information about the error.
    :type extra: str
    """

    def __init__(
        self,
        kind: Literal["error", "note", "warning"],
        error_code: Optional[str],
        msg: str,
        file: str,
        row: int,
        col: int,
        refer: Dict[int, str],
        extra: str,
    ):
        self.kind: Literal["error", "note", "warning"] = kind
        self.error_code: Optional[str] = error_code
        self.msg: str = msg
        self.file: str = file
        self.row: int = row
        self.col: int = col
        self.refer: Dict[int, str] = refer
        self.extra: str = extra

    # def __str__(self):
    #     return (
    #         f"{self.error_code}: {self.msg} ({self.file}:{self.row}:{self.col}):\n"
    #         + "".join(f"{line} {detail}" for line, detail in self.refer.items())
    #         + f"{self.extra}"
    #     )
    def __str__(self):
        return (
            f"At {self.row}:{self.col}, {self.msg}\nDetails:\n"
            + "".join(f"line {line}:\n{detail}" for line, detail in self.refer.items())
            + self.extra
        )

    def __repr__(self):
        return self.__str__()


def _split_error_messages(text: str) -> List[str]:
    errors = []
    current_error = None
    for line in text.splitlines():
        if (
            line.startswith("error:")
            or line.startswith("note:")
            or line.startswith("warning:")
            or re.match(r"^error\[E\d{4}\]:", line)
        ):
            if current_error is not None:
                errors.append(current_error)
            current_error = ""
            current_error += line + "\n"
        else:
            if current_error is not None:
                current_error += line + "\n"
    if current_error is not None:
        errors.append(current_error)
    return errors


def _parse_error(error: str) -> Optional[RustErrorMessages]:
    lines = error.splitlines()
    if len(lines) < 2:
        print(error)
        return None
    error_msg_line = lines[0]
    error_pos_line = lines[1]
    error_details = lines[2:]

    error_kind = None
    error_code = None
    error_msg = ""
    if match := re.match(
        r"(?P<kind>error|note|warning)(\[(?P<code>E\d{4})\])?: (?P<msg>.*)",
        error_msg_line,
    ):
        if match["code"] is not None:
            error_code = match["code"]
        error_msg = match["msg"]
        error_kind = match["kind"]
    if not error_code and not error_msg:
        # No information about the error
        return None

    match = re.search(r"--> (.*?):([0-9]{1,5}):([0-9]{1,5})", error_pos_line)
    if match:
        error_file = match.group(1)
        error_row = int(match.group(2))
        error_col = int(match.group(3))
    else:
        error_file = ""
        error_row = 0
        error_col = 0

    refer = {}
    line_num = None
    detail = None
    extra = ""
    in_extra = False
    for line in error_details:
        if in_extra:
            extra += line + "\n"
            continue
        if match := re.match(r"(?P<line>\d+)?\s+(?P<detail>\|.*)", line):
            if match["line"] is not None:
                if line_num is not None:
                    refer[line_num] = detail
                line_num = int(match["line"])
                detail = ""
            if detail is not None:
                detail += match["detail"] + "\n"
        elif line == "...":
            continue
        elif match := re.match(r"\s+= \w+:.*", line):
            extra += line + "\n"
            in_extra = True
    if line_num is not None:
        refer[line_num] = detail
    return RustErrorMessages(
        error_kind,
        error_code,
        error_msg,
        error_file,
        error_row,
        error_col,
        refer,
        extra,
    )


def parse_error_messages(text: str) -> List[RustErrorMessages]:
    errors = _split_error_messages(text)
    return [msg for error in errors if (msg := _parse_error(error)) is not None]
