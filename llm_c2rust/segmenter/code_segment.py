from collections import defaultdict
from collections.abc import Generator
from typing import TypeAlias

CodeSliceID: TypeAlias = str
id_count = 0


class CodeSegment(object):
    """
    A code slice is the smallest unit of code that we can provide. A slice contains at least one top-level declaration of entity.
    Here "top-level" means the entities declared inside another entity are not to individual slices, but contained in their outer entities' slices
    Entities include global variables, functions(and member functions), user-types, macros, but not namespaces and linkage specifiers.
    So the stuffs inside the namespaces or linkage specifiers are considered as top-level.

    Attributes:
        loc (str): source location and the id of the code slice, in the format of "file:start_line-end_line"
        file (str): the file path of the code slice
        start_line (int): the start line of the code slice
        end_line (int): the end line of the code slice
        decls (list[tuple[str, str]]): a list of (declaration type, name) in the code slice. Declarations include:
            - Definitions of functions, excluding the compiler generated constructors, operators.
            - Definitions of global variables. Supposed there is no global variable generated by compiler.
            - Declarations of user-types. Notice that a user-type can be "defined" multiple times in different files as long as it appears only once in the source file.
            This will create multiple slices and they are depended on at the same time. Let's wish the source code not so ugly!
            TODO: make multiple declarations of the same user-type as one slice. Qualified names are the identities of types!
            - Macros
            - Not template initializations.
        depends (set[CodeSlice]): a set of code slices that this code slice depends on. "Depend" means a code slice uses something declared in other code slices.
            - The definition of declaration is depended on if there is.
            - Field access is also a dependency.
            - No self-dependency.
        depended (set[CodeSlice]): a set of code slices that depends on this code.
        extra: some other info about this slice.
        level: negative number, the smaller the lower, topo order of this slice among all slices.
        text: the text of the code slice
    """

    pool: "CodeSegmentPool | None"
    file: str
    start_line: int
    end_line: int
    decls: list[tuple[str, str]]
    text: str
    use: set["CodeSegment"]
    used: set["CodeSegment"]
    level: int
    has_main: bool
    # size: int

    def __init__(
        self, pool: "CodeSegmentPool | None", file: str, start_line: int, end_line: int
    ):
        global id_count
        self.pool = pool
        self.file: str = file
        self.start_line: int = start_line
        self.end_line: int = end_line
        self.decls: list[tuple[str, str]] = []
        self.text: str = ""
        self.use = set()
        self.used = set()
        self.level = 0
        self.size = 0
        self.has_main = False
        self.id = str(id_count)
        id_count += 1

    @property
    def loc(self) -> str:
        return f"{self.file}:{self.start_line}-{self.end_line}"

    def cover(self, other: "CodeSegment") -> bool:
        if not isinstance(other, CodeSegment):
            return NotImplemented("CodeSlice-cover: other must be a CodeSlice")
        return self.start_line <= other.start_line and other.end_line <= self.end_line

    def __hash__(self):
        if hasattr(self, "id"):
            return hash(self.id)
        else:
            return super(CodeSegment, self).__hash__()

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, CodeSegment):
            return NotImplemented
        return self.loc == other.loc

    def __lt__(self, other: object) -> bool:
        if not isinstance(other, CodeSegment):
            return NotImplemented
        return self.loc < other.loc

    def __repr__(self) -> str:
        return (
            f"CodeSlice(file='{self.file}', start_line={self.start_line}, "
            f"end_line={self.end_line}, "
            f"decls={self.decls})"
        )

    def isTest(self):
        return any(decl[1].startswith("test_") for decl in self.decls)

    def isTypedef(self):
        return any(decl[0] == "CTypedefType" for decl in self.decls)

    def isFunction(self) -> bool:
        return any(decl[0].endswith("Function") for decl in self.decls)

    def use_symbol_in(self, dependency: "CodeSegment"):
        """
        This method add dependency of this code slice. Do nothing if the dependency is itself.
        """
        if self.pool is None:
            raise ValueError("Cannot depends_on CodeSlice from None pool.")

        if dependency == self:
            return

        self.use.add(dependency)
        dependency.used.add(self)


class CodeSegmentPool:
    namespace: str
    code_segments: dict[str, list[CodeSegment]]

    def __init__(self, namespace: str = "CodeSlice") -> None:
        self.namespace = namespace
        self.code_segments: dict[str, list[CodeSegment]] = defaultdict(list)

    def get_slice_by_id(self, id: CodeSliceID) -> CodeSegment:
        ret = None
        for file_name, slices in self.code_segments.items():
            for slice in slices:
                if slice.id == id:
                    ret = slice
                    break
            if ret is not None:
                break
        if ret is None:
            raise KeyError(f"Slice {id} not found")
        return ret

    def all_segments(self) -> Generator[CodeSegment, None, None]:
        for segments in self.code_segments.values():
            yield from segments

    def add_segment(self, code: CodeSegment) -> bool:
        to_remove = []
        for code_slice in self.code_segments[code.file]:
            if code_slice.cover(code):
                return False
            if code.cover(code_slice):
                to_remove.append(code_slice)
        for code_slice in to_remove:
            self.code_segments[code.file].remove(code_slice)
        self.code_segments[code.file].append(code)
        code.pool = self
        return True

    def find_code_slice(
        self, file: str, start_line: int, end_line: int
    ) -> CodeSegment | None:
        for code in self.code_segments[file]:
            if code.start_line <= start_line <= end_line <= code.end_line:
                return code
        return None

    def seal(self) -> None:
        """
        Call this when all code slices are all collected, this will remove the code slices without declarations. And fill the text of the code slices.
        """
        all_segments = set()
        code_segments = {}
        for file, segments in self.code_segments.items():
            code_segments[file] = []
            for s in segments:
                if not s.decls:
                    continue
                if all(d[0] == "Macro" for d in s.decls) and not s.used:
                    continue
                code_segments[file].append(s)
                all_segments.add(s)
        self.code_segments = code_segments
        for s in self.all_segments():
            s.use = {d for d in s.use if d in all_segments}
            s.used = {d for d in s.used if d in all_segments}

        for file, slices in self.code_segments.items():
            with open(file, "r") as f:
                lines = f.readlines()
            for slice in slices:
                if not slice.text:
                    slice.text = "".join(lines[slice.start_line - 1 : slice.end_line])
